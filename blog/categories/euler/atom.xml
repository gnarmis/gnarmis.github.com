<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: euler | Kilotau]]></title>
  <link href="http://gnarmis.github.com/blog/categories/euler/atom.xml" rel="self"/>
  <link href="http://gnarmis.github.com/"/>
  <updated>2013-01-05T13:44:35-06:00</updated>
  <id>http://gnarmis.github.com/</id>
  <author>
    <name><![CDATA[Gursimran Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler Problem 3 using Clojure 1.5 and a lazy technique]]></title>
    <link href="http://gnarmis.github.com/blog/2013/01/05/project-euler-problem-3-using-clojure-1-dot-5-and-a-lazy-technique/"/>
    <updated>2013-01-05T12:36:00-06:00</updated>
    <id>http://gnarmis.github.com/blog/2013/01/05/project-euler-problem-3-using-clojure-1-dot-5-and-a-lazy-technique</id>
    <content type="html"><![CDATA[<p>The problem: find the largest prime factor of 600851475143.</p>

<p>I used the Sieve of Eratosthenes and Ruby to solve it <a href="http://kilotau.com/blog/2011/06/28/primes-and-sieves/">last time</a>.</p>

<p>This time, I tried a lazy, functional approach. The result was an efficient,
straightfoward solution that involved no sieve or any static/full-realized
data structure at all! I make a recipe for the kind of numbers I want and
then take just as many as I need in order to finally output the answer.</p>

<p>Here's my lazy, functional implementation using Clojure 1.5 RC1 (mostly because
I wanted to play with the new reducers library). It's pretty efficient: less
than a quarter of a second on my 2011 13" base MBP!</p>

<p>```clojure
(ns euler.three
 (require [clojure.core.reducers :as r]))</p>

<p>(declare largest-prime-factor-for)
(declare factors-of)
(declare source-factors)
(declare source-naturals)
(declare factor?)
(declare prime?)
(declare certainty)</p>

<p>(defn answer []
  (time (largest-prime-factor-for 600851475143)))</p>

<p>(defn largest-prime-factor-for [n]
  (let [prime-factors (r/filter prime?</p>

<pre><code>                            (factors-of n))]
(last (into [] prime-factors))))
</code></pre>

<p>(defn factors-of [n]
  (r/filter #(factor? n %)</p>

<pre><code>        (source-factors n)))
</code></pre>

<p>(defn source-factors [n]
  (r/take-while #(&lt; % (int (Math/sqrt n)))</p>

<pre><code>            (source-naturals)))
</code></pre>

<p>(defn source-naturals []
  (r/map #(+ % 2) (range)))</p>

<p>(defn factor? [n possib]
  (zero? (mod n possib)))</p>

<p>(defn prime? [n]
  (.isProbablePrime (BigInteger/valueOf n) certainty))</p>

<p>(def certainty 10)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primes and Sieves]]></title>
    <link href="http://gnarmis.github.com/blog/2011/06/28/primes-and-sieves/"/>
    <updated>2011-06-28T00:39:00-05:00</updated>
    <id>http://gnarmis.github.com/blog/2011/06/28/primes-and-sieves</id>
    <content type="html"><![CDATA[<p><a href="http://projecteuler.net/">Project Euler</a> is one of the best things I have discovered in a while.
It's simply a huge open list of problems in numeric order that you can solve
using any math or code you want, provided that any code you write runs under
one minute.</p>

<p>The problems get interesting from the very start and are actually entertaining!
After reading <a href="https://www.facebook.com/l.php?u=http%3A%2F%2Fwww.maa.org%2Fdevlin%2FLockhartsLament.pdf&amp;h=dba0d">Lokhart's Lament</a>, I'd say these problems would definitely
fit the category of challenging and yet stimulating. Math truly is an art,
and code is a cool way to access a subset of it.</p>

<p> </p>

<p>Anyway, primes! Here's the problem itself:</p>

<p>The prime factors of 13195 are 5, 7, 13 and 29.</p>

<p>What is the largest prime factor of the number 600851475143 ?</p>

<p>And here's my solution (skip if you want to try this yourself!):</p>

<p>``` ruby
def maxPrimeFactor(n) #=> maxPrimeFactor(600851475143) => 6857 in 2007.562 ms
  # limit the ridiculous range safely
  range = n**(1/Math.sqrt(n.to_s.length).floor.to_f)
  ary = (1..range).to_a
  # Sieve of Eratosthenes (replace with Sieve of Atkin?)
  for i in ary</p>

<pre><code>for j in ary
  if i != j
    if (j % i == 0)
      ary.delete(j)
    end
  end
end
</code></pre>

<p>  end
  #remove non-factor primes
  ary.delete_if{|k| ( n % k != 0)}
  ary.max
end
```</p>

<p>The code should be pretty much clear, at least except for that initial part
where I restrict the range. It was hard getting my super-easy-to-write-yet-inefficient
prime numbered array generator to solve for 600851475143 quickly. I was too
lazy to try to implement Sieve of Atkin so I just decided to try limiting the
range as much as I could. Apparently, if you take the root of the number of
digits in the given composite number, and then raise the upper limit of your
range to the inverse of that number, you get a much more limited range that
still gives you the right highest prime factor of the original number. I tried
this out down to two-digit composites and it seems to work.</p>

<p>Also, if I tried using a quick prime test on each element and deleting non-primes
that way (instead of a sieve), the performance was actually worse somehow.
And while trying to do this exact thing, I discovered a freaking <a href="http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">regular expression
that detects primes</a>! Yeah.</p>

<p>I literally spent close to three hours just researching a number of tangential
topics, such as <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratothenes</a>, <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">Sieve of Atkin</a>, <a href="http://en.wikipedia.org/wiki/Sieve_theory">Sieve theory</a>,
<a href="http://en.wikipedia.org/wiki/GNFS">GNFS</a>, and <a href="http://en.wikipedia.org/wiki/RSA">RSA</a>. While the problem itself wasn't too challenging (I
ended up learning much more about Ruby, though), the whole experience was amazing.
And of course, there's a lot of room for gains in efficiency too.</p>

<p>I highly recommend you sign up for an account on <a href="http://projecteuler.net/">Project Euler</a> and work
your way through some of those problems! It's a great way to try out new languages,
learn more efficient techniques, or just have some fun. No, really, it's actually
fun.</p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
</feed>
