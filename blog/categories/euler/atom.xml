<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: euler | Kilotau]]></title>
  <link href="http://gnarmis.github.com/blog/categories/euler/atom.xml" rel="self"/>
  <link href="http://gnarmis.github.com/"/>
  <updated>2013-01-05T12:52:19-06:00</updated>
  <id>http://gnarmis.github.com/</id>
  <author>
    <name><![CDATA[Gursimran Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler Problem 3 using Clojure 1.5 and a lazy technique]]></title>
    <link href="http://gnarmis.github.com/blog/2013/01/05/project-euler-problem-3-using-clojure-1-dot-5-and-a-lazy-technique/"/>
    <updated>2013-01-05T12:36:00-06:00</updated>
    <id>http://gnarmis.github.com/blog/2013/01/05/project-euler-problem-3-using-clojure-1-dot-5-and-a-lazy-technique</id>
    <content type="html"><![CDATA[<p>The problem: find the largest prime factor of 600851475143.</p>

<p>I used the Sieve of Eratosthenes and Ruby to solve it <a href="http://kilotau.com/blog/2011/06/28/primes-and-sieves/">last time</a>.</p>

<p>This time, I tried a lazy, functional approach. The result was an efficient,
straightfoward solution that involved no sieve or any static/full-realized
data structure at all! I make a recipe for the kind of numbers I want and
then take just as many as I need in order to finally output the answer.</p>

<p>Here's my lazy, functional implementation using Clojure 1.5 RC1 (mostly because
I wanted to play with the new reducers library). It's pretty efficient: less
than a quarter of a second on my 2011 13" base MBP!</p>

<script src="https://gist.github.com/4463032.js"></script>

]]></content>
  </entry>
  
</feed>
