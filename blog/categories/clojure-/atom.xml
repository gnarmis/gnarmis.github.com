<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure, | Kilotau]]></title>
  <link href="http://gnarmis.github.com/blog/categories/clojure-/atom.xml" rel="self"/>
  <link href="http://gnarmis.github.com/"/>
  <updated>2013-01-05T12:48:13-06:00</updated>
  <id>http://gnarmis.github.com/</id>
  <author>
    <name><![CDATA[Gursimran Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler Problem 3 using Clojure 1.5 and a lazy technique]]></title>
    <link href="http://gnarmis.github.com/blog/2013/01/05/project-euler-problem-3-using-clojure-1-dot-5-and-a-lazy-technique/"/>
    <updated>2013-01-05T12:36:00-06:00</updated>
    <id>http://gnarmis.github.com/blog/2013/01/05/project-euler-problem-3-using-clojure-1-dot-5-and-a-lazy-technique</id>
    <content type="html"><![CDATA[<p>The problem: find the largest prime factor of 600851475143.</p>

<p>I used the Sieve of Eratosthenes and Ruby to solve it last time.</p>

<p>This time, I tried a lazy, functional approach. The result was an efficient,
straightfoward solution that involved no sieve or any static/full-realized
data structure at all! I make a recipe for the kind of numbers I want and
then take just as many as I need in order to finally output the answer.</p>

<p>Here's my lazy, functional implementation using Clojure 1.5 RC1 (mostly because
I wanted to play with the new reducers library). It's pretty efficient: less
than a quarter of a second on my 2011 13" base MBP!</p>

<p><div><script src='https://gist.github.com/4463032.js?file='></script>
<noscript><pre><code>(ns euler.three
 (require [clojure.core.reducers :as r]))

(declare largest-prime-factor-for)
(declare factors-of)
(declare source-factors)
(declare source-naturals)
(declare factor?)
(declare prime?)
(declare certainty)

(defn answer []
  (time (largest-prime-factor-for 600851475143)))

(defn largest-prime-factor-for [n]
  (let [prime-factors (r/filter prime?
                                (factors-of n))]
    (last (into [] prime-factors))))

(defn factors-of [n]
  (r/filter #(factor? n %)
            (source-factors n)))

(defn source-factors [n]
  (r/take-while #(&lt; % (int (Math/sqrt n)))
                (source-naturals)))

(defn source-naturals []
  (r/map #(+ % 2) (range)))

(defn factor? [n possib]
  (zero? (mod n possib)))

(defn prime? [n]
  (.isProbablePrime (BigInteger/valueOf n) certainty))

(def certainty 10)</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
</feed>
