<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Kilotau]]></title>
  <link href="http://gnarmis.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://gnarmis.github.com/"/>
  <updated>2013-01-05T12:48:13-06:00</updated>
  <id>http://gnarmis.github.com/</id>
  <author>
    <name><![CDATA[Gursimran Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RepoMap: track your local git repositories]]></title>
    <link href="http://gnarmis.github.com/blog/2012/12/18/repomap-track-your-local-git-repositories/"/>
    <updated>2012-12-18T16:09:00-06:00</updated>
    <id>http://gnarmis.github.com/blog/2012/12/18/repomap-track-your-local-git-repositories</id>
    <content type="html"><![CDATA[<p>Github link: <a href="http://github.com/gnarmis/repomap">RepoMap</a></p>

<p>There are hundreds of git repositories stored at various folder depths all over
my computer. Organizing them, remembering where they are or determining whether
I still have a working copy cloned from a remote repository is a chore.</p>

<p>So, why not have a map of where all my repositories are? Should be simple
enough to keep a YAML file with a map from paths to repository names.</p>

<p>After some hacking on a flight (after having finished finals and an interview),
I made a little Ruby CLI program and found it to be useful enough to expand into
a tiny little gem. It's still very basic, and specs aren't where they should be,
but the essentials are there.</p>

<p>It's called RepoMap, and you can find it here:
<a href="http://github.com/gnarmis/repomap">http://github.com/gnarmis/repomap</a>.</p>

<p>You can also install it by typing <code>gem install repomap</code>.</p>

<p>Check out the above link for details about how it works. Pull requests are
welcome! I'm thinking there's a number of cool additions possible, such as
mining all that useful meta data about git repositories, and making use of the
map in interesting ways.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby's `method_missing` is cool / hashes as functions of their keys]]></title>
    <link href="http://gnarmis.github.com/blog/2012/09/26/rubys-method-missing-is-kinda-nice/"/>
    <updated>2012-09-26T11:59:00-05:00</updated>
    <id>http://gnarmis.github.com/blog/2012/09/26/rubys-method-missing-is-kinda-nice</id>
    <content type="html"><![CDATA[<p>I had an idea to try and bring a tiny bit of Clojure's ideas of hash-maps to Ruby's hashes. I came up with a simple monkey-patch that allows you to truly use hashes as functions of their keys. In the process, I've come to really dig <code>method_missing</code>, although debugging it can be a chore. Word of advice: always implement <code>respond_to?</code> with your <code>method_missing</code>. Principle of Least Surprise, people.</p>

<p><div><script src='https://gist.github.com/3789174.js?file=functional_hash.rb'></script>
<noscript><pre><code># In Clojure, hash-maps are truly functions of keys to values.
# So you can do `(:a {:a 1})` and get `1` as the result
# Why not put this in Ruby?

# access keys of a hash like a function

class Object
  def respond_to?(method)
    if (method.to_s =~ /^_.*/) == 0
      true
    else
      super
    end
  end
  def method_missing(name, *args, &amp;b)
    if (args.count==1) &amp;&amp; b.nil? &amp;&amp; name[0]==&quot;_&quot; &amp;&amp;
       args[0].has_key?(name[1..-1].to_sym)
      args[0][name[1..-1].to_sym]
    else
      super
    end
  end
end


hash = {:a =&gt; 1}
(_a hash) == 1 #=&gt; true
(_a hash) == (hash [:a]) #=&gt; true

# the underscore serves to prevent naming conflicts to a degree


</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Ruby 1.9's Flexible Syntax]]></title>
    <link href="http://gnarmis.github.com/blog/2012/09/25/on-ruby-1-dot-9-s-flexible-syntax/"/>
    <updated>2012-09-25T13:57:00-05:00</updated>
    <id>http://gnarmis.github.com/blog/2012/09/25/on-ruby-1-dot-9-s-flexible-syntax</id>
    <content type="html"><![CDATA[<p>Over the past day or so, I've been playing around with small bits of Ruby after spending most of the summer in Clojure-land. There's great similarities in both Ruby and Clojure (functional style, dynamic, etc), and both are very practical choices. Clojure gives you amazing access to JVM land while not forcing you to pull your hair out, and Ruby grants you a good selection of libraries and amazing tools for web development.</p>

<p>But here I want to highlight a few experiments I did to try and brighten up my Ruby-writing experience. The things here could be unneccessarily divergent, but what the hell. It made me realize you can bend Ruby in a lot of ways I hadn't thought of before</p>

<h2>define methods on the fly</h2>

<p><code>ruby
def defn name, &amp;b
  Object.send :define_method, name, &amp;b
end
</code></p>

<p><code>:define_method</code> is an amazing little method that allows you define methods (on any object too, so you could define class/module methods). That's all there is to it. Now you can do this:</p>

<p>```ruby
defn(:a) {|x, *y| print x; print y}</p>

<h1>and if you want to superficially lispy</h1>

<p>(defn (:a) {|x, *y| print x; print y})</p>

<p>(a 1, 2, 3, 4) #-> 1[2,3,4]</p>

<h1>for multiline methods, this seems easier:</h1>

<p>defn (:sum_of_squares) do |x, y|
  x<em>x + y</em>y
end
```</p>

<p>This also works for associating any name with any kind of lambda.</p>

<p><code>ruby
(defn (:foo) {23})
foo == 23 #=&gt; true
</code></p>

<h2>let / with</h2>

<p>In Lispy languages, there's something like a function called <code>let</code> which lets you define some names in a new lexical scope and operate with them. An example in Clojure:</p>

<p><code>clojure
(let [x 1] x) ;-&gt; 1
x ;-&gt; error, x is not defined outside the above form
</code></p>

<p>In Ruby, we have something kind of like that called <code>#tap</code>, which Zach Hobson covered <a href="http://www.opensourcery.com/blog/zack-hobson/objectlet-ruby-0">here</a>. He suggested a simple way to define <code>#let</code>:</p>

<p>```ruby
class Object
  def let</p>

<pre><code>yield self
</code></pre>

<p>  end
end</p>

<h1>Now you can do this:</h1>

<p>((2).let {|x| puts x+1}) == 3 #=> true
```</p>

<p>But I think an even more beautiful way to do it is like this:</p>

<p>```ruby
def with coll, &amp;b
 coll.map &amp;b
end</p>

<p>with [[1,2]] {|x,y| puts x+y} #=> 3
```</p>

<p>For more on destructuring and everything's that's possible there, check out <a href="http://po-ru.com/diary/destructuring-assignment-in-ruby/">this post</a>.</p>

<h2>map, reduce, filter, pipe, call, body</h2>

<p>There's a lot more craziness to explore. I'll let the code, comments, and examples from my <a href="https://gist.github.com/3760519">gist</a> explain. This is just bits of code here and there, honestly. <a href="http://twitter.com/gnarmis">Tweet at me</a> to discuss! Also, the <a href="https://gist.github.com/3760519">gist</a> will be the most up-to-date version of this.</p>

<p>```ruby</p>

<h1>execute an array of lambdas one after another?</h1>

<p>def body *args
  args.each {|e| e.call}
end</p>

<p>(body (lambda {print 1}), (lambda {print 2})) #=> output: 12</p>

<h1>map as a "top-level" function. This maps some lambda to an array,</h1>

<h1>passing each element to the lambda to call.</h1>

<h1>(also, who doesn't like stabby lambdas?)</h1>

<p>def map fun, coll
  coll.to_a.collect {|i| fun.call(i)}
end</p>

<p>(map ->(x){x+1}, [1,2,3]) #=> [2, 3, 4]</p>

<h1>reduce as a "top-level" function</h1>

<p>def reduce fun, val=nil, coll
  return coll.to_a.reduce(fun.to_sym) unless val
  return coll.to_a.reduce(val) {|sum, i| sum.send fun.to_sym, i} if val
end</p>

<p>(reduce :+, [1,2,3]) #=> 6
(reduce :+, 3, [1,2,3]) #=> 9</p>

<h1>piping a single input through a bunch of functions</h1>

<h1>(yay, composable functions!)</h1>

<p>def pipe args, *methods
 methods.reduce(args) { |a, m| send(m, a) }
end</p>

<p>def foo(data)
  data[:a] += 1
  data
end</p>

<p>def bar(data)
  data[:b] += 10
  data
end</p>

<p>hash = {:a => 0, :b => 0}
(pipe hash, :foo, :bar) #=> {:a=>1, :b=>10}</p>

<h1>good old filter is also pretty easy to define</h1>

<p>def filter pred, coll
  coll.to_a.select &amp;pred
end</p>

<p>(filter ->(x){x.even?}, [1,2,3]) == [2] #=> true</p>

<h1>a function to call a lambda (forcing it to execute)</h1>

<p>def call b; b.call; end</p>

<p>saved = lambda {puts "did I get called?"}</p>

<h1>=> #&lt;Proc:blahblahblah (lambda)></h1>

<p>(call (lambda {puts "I got called!"; reduce :+, [1,2,3]}))</p>

<h1>=> output: I got called!\n => 6</h1>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Piping Arguments Through Multiple Functions in Ruby]]></title>
    <link href="http://gnarmis.github.com/blog/2012/09/19/piping-arguments-through-multiple-functions-in-ruby/"/>
    <updated>2012-09-19T16:25:00-05:00</updated>
    <id>http://gnarmis.github.com/blog/2012/09/19/piping-arguments-through-multiple-functions-in-ruby</id>
    <content type="html"><![CDATA[<p>After asking <code>#ruby</code> what the equivalent of Clojure's <a href="http://clojuredocs.org/clojure_core/clojure.core/-%3E">-> macro</a> could look like, I compiled the collective solution into a gist. You might find this useful somewhere, especially when you have multiple transformation functions operating on the same basic data structures.</p>

<p><div><script src='https://gist.github.com/3752271.js?file=piping_example.rb'></script>
<noscript><pre><code># piping example in Ruby

def foo(data)
  data[:a] += 1
  data
end

def bar(data)
  data[:b] += 10
  data
end

def pipe args, *methods
 methods.reduce(args) { |a, m| send(m, a) }
end

hash = {:a =&gt; 0, :b =&gt; 0}
pipe hash, :foo, :bar
#=&gt; {:a=&gt;1, :b=&gt;10}</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primes and Sieves]]></title>
    <link href="http://gnarmis.github.com/blog/2011/06/28/primes-and-sieves/"/>
    <updated>2011-06-28T00:39:00-05:00</updated>
    <id>http://gnarmis.github.com/blog/2011/06/28/primes-and-sieves</id>
    <content type="html"><![CDATA[<p><a href="http://projecteuler.net/">Project Euler</a> is one of the best things I have discovered in a while.
It's simply a huge open list of problems in numeric order that you can solve
using any math or code you want, provided that any code you write runs under
one minute.</p>

<p>The problems get interesting from the very start and are actually entertaining!
After reading <a href="https://www.facebook.com/l.php?u=http%3A%2F%2Fwww.maa.org%2Fdevlin%2FLockhartsLament.pdf&amp;h=dba0d">Lokhart's Lament</a>, I'd say these problems would definitely
fit the category of challenging and yet stimulating. Math truly is an art,
and code is a cool way to access a subset of it.</p>

<p> </p>

<p>Anyway, primes! Here's the problem itself:</p>

<p>The prime factors of 13195 are 5, 7, 13 and 29.</p>

<p>What is the largest prime factor of the number 600851475143 ?</p>

<p>And here's my solution (skip if you want to try this yourself!):</p>

<p><div><script src='https://gist.github.com/1050563.js?file='></script>
<noscript><pre><code>def maxPrimeFactor(n) #=&gt; maxPrimeFactor(600851475143) =&gt; 6857 in 2007.562 ms
  # limit the ridiculous range safely
  range = n**(1/Math.sqrt(n.to_s.length).floor.to_f)
  ary = (1..range).to_a
  # Sieve of Eratosthenes (replace with Sieve of Atkin?)
  for i in ary
    for j in ary
      if i != j
        if (j % i == 0)
          ary.delete(j)
        end
      end
    end
  end
  #remove non-factor primes
  ary.delete_if{|k| ( n % k != 0)}
  ary.max
end</code></pre></noscript></div>
</p>

<p>The code should be pretty much clear, at least except for that initial part
where I restrict the range. It was hard getting my super-easy-to-write-yet-inefficient
prime numbered array generator to solve for 600851475143 quickly. I was too
lazy to try to implement Sieve of Atkin so I just decided to try limiting the
range as much as I could. Apparently, if you take the root of the number of
digits in the given composite number, and then raise the upper limit of your
range to the inverse of that number, you get a much more limited range that
still gives you the right highest prime factor of the original number. I tried
this out down to two-digit composites and it seems to work.</p>

<p>Also, if I tried using a quick prime test on each element and deleting non-primes
that way (instead of a sieve), the performance was actually worse somehow.
And while trying to do this exact thing, I discovered a freaking <a href="http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">regular expression
that detects primes</a>! Yeah.</p>

<p>I literally spent close to three hours just researching a number of tangential
topics, such as <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratothenes</a>, <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">Sieve of Atkin</a>, <a href="http://en.wikipedia.org/wiki/Sieve_theory">Sieve theory</a>,
<a href="http://en.wikipedia.org/wiki/GNFS">GNFS</a>, and <a href="http://en.wikipedia.org/wiki/RSA">RSA</a>. While the problem itself wasn't too challenging (I
ended up learning much more about Ruby, though), the whole experience was amazing.
And of course, there's a lot of room for gains in efficiency too.</p>

<p>I highly recommend you sign up for an account on <a href="http://projecteuler.net/">Project Euler</a> and work
your way through some of those problems! It's a great way to try out new languages,
learn more efficient techniques, or just have some fun. No, really, it's actually
fun.</p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
</feed>
